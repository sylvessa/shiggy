#include "globals.h"
#include "cpu/isr.h"
#include "drivers/screen.h"
#include "drivers/ata.h"

#define ATA_PRIMARY_IO 0x1F0
#define ATA_PRIMARY_CTRL 0x3F6

static int ata_irq_triggered = 0;

void ata_irq_handler(registers_t r) {
	// acknowledge pic
	out_byte(0x20, 0x20);
	// read status to clear interrupt
	in_byte(ATA_PRIMARY_IO + 7);
	ata_irq_triggered = 1;
}

void init_ata() {
	register_interrupt_handler(IRQ_BASE + 14, ata_irq_handler);
}

static nat16 ata_read_data16() {
	nat16 data = in_b16(ATA_PRIMARY_IO);
	return data;
}

nat32 ata_get_drive_size() {
	nat16 buffer[256];
	for (int i = 0; i < 256; i++)
		buffer[i] = ata_read_data16();

	nat32 sectors = ((nat32)buffer[61] << 16) | buffer[60]; // total sectors
	return sectors;
}


int ata_identify() {
	out_byte(ATA_PRIMARY_CTRL, 0x0); // enable interrupts
	out_byte(ATA_PRIMARY_IO + 6, 0xA0); // select master drive
	out_byte(ATA_PRIMARY_IO + 2, 0x0); // sector count
	out_byte(ATA_PRIMARY_IO + 3, 0x0);
	out_byte(ATA_PRIMARY_IO + 4, 0x0);
	out_byte(ATA_PRIMARY_IO + 5, 0x0);
	out_byte(ATA_PRIMARY_IO + 7, 0xEC); // IDENTIFY command

	nat8 status = in_byte(ATA_PRIMARY_IO + 7);
	if (status == 0) {
		//print("no drive present on primary master\n");
		return 0;
	}

	while ((status & 0x80) != 0) // wait for BSY clear
		status = in_byte(ATA_PRIMARY_IO + 7);

	nat8 cl = in_byte(ATA_PRIMARY_IO + 4);
	nat8 ch = in_byte(ATA_PRIMARY_IO + 5);
	if (cl != 0 || ch != 0) {
		//print("not an ata device\n");
		return 0;
	}

	while (1) {
		status = in_byte(ATA_PRIMARY_IO + 7);
		if (status & 0x08) break; // DRQ set
	}

	//print("IDE drive detected\n");
	return 1;
}